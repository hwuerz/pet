#include "gfe.h"
#include "stdlib.h"
#include "stdio.h"
#include <math.h>

typedef float float32_t;

/*
 * From: https://github.com/bvssvni/fwht/blob/master/fwht.c
 * edited by Nils Dycke
 */

/*
 * Receives a 16*uint array for r and a 16*uint array for x
 * or a 32*uint array for r and a 32*uint array for x
 * Assuming that for both cases it is supposed to be applied to the lower 16 entries.
 *
 * NOTE: This implementation was simply copied from github and hence is not necessarily
 *       designed to be used with gfes etc. A comparison of this method and the one below
 *       shows, that they are not equivalent. But maybe there might be some correction possible.
 */
/*void hadamard(uint32 *r, const uint32 *x){
	const int n = 32;
	uint32 adata[n];
    uint32 bdata[n];
    uint32 *a = adata;
    uint32 *b = bdata;
    void *tmp;
    memcpy(a, x, sizeof(uint32)*n);
    
    // Fast Walsh Hadamard Transform.
    int i, j, s;
    for (i = n>>1; i > 0; i>>=1) {
        for (j = 0; j < n; j++) {
            s = j/i%2;
            b[j]=a[(s?-i:0)+j]+(s?-1:1)*a[(s?0:i)+j];
        }
        tmp = a; a = b; b = tmp;
    }
    
	memcpy(r, a, sizeof(uint32)*n);
}*/


//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler  <info@retdec.com>
//
/*
 * This leads to invalid signatures - at least it does not work out
 * for the given tests.
 */
void hadamard(uint32 * a1, const uint32 * a2) {
    uint32 v1 = (uint32)a1;
    uint32 v2 = (uint32)a2;
    uint32 v3 = *a2;
    uint32 v4 = *(uint32 *)(v2 + 4);
    uint32 v5 = *(uint32 *)(v2 + 8);
    uint32 v6 = *(uint32 *)(v2 + 12);
    uint32 * v7 = (uint32 *)(v2 + 16);
    uint32 * v8 = (uint32 *)(v2 + 20);
    uint32 * v9 = (uint32 *)(v2 + 24);
    uint32 * v10 = (uint32 *)(v2 + 28);
    uint32 v11 = *v10 + v6; // bp+38
    float32_t v12 = fabsf((float32_t)v11);
    *a1 = *v7 + v3 + (uint32)(v11 < 0);
    uint32 * v13 = (uint32 *)(v1 + 4);
    *v13 = *v8 + v4;
    uint32 * v14 = (uint32 *)(v1 + 8);
    *v14 = *v9 + v5;
    uint32 * v15 = (uint32 *)(v1 + 12);
    *v15 = (uint32)v12;
    uint32 * v16 = (uint32 *)(v1 + 16);
    *v16 = *v7 - v3 - 2;
    uint32 * v17 = (uint32 *)(v1 + 20);
    *v17 = *v8 - v4 - 4;
    uint32 * v18 = (uint32 *)(v1 + 24);
    *v18 = *v9 - v5 - 2;
    uint32 * v19 = (uint32 *)(v1 + 28);
    *v19 = *v10 - v6 - 2;
    uint32 result = v1 + 32;
    uint32 * v20 = (uint32 *)(v2 + 32);
    uint32 * v21 = (uint32 *)(v2 + 36);
    uint32 * v22 = (uint32 *)(v2 + 40);
    uint32 * v23 = (uint32 *)(v2 + 44);
    uint32 * v24 = (uint32 *)(v2 + 48);
    uint32 * v25 = (uint32 *)(v2 + 52);
    uint32 * v26 = (uint32 *)(v2 + 56);
    uint32 * v27 = (uint32 *)(v2 + 60);
    uint32 v28 = *v27 + *v23;
    float32_t v29 = fabsf((float32_t)v28);
    uint32 v30 = (uint32)(v28 < 0) + *v24 + *v20; // R8
    uint32 v31 = *v25 + *v21; // R9
    uint32 v32 = *v26 + *v22; // R10
    uint32 v33 = v29; // R11
    uint32 v34 = *v20 - *v24 - 2; // bp+160
    uint32 v35 = *v22 - 2 - *v26; // R4
    uint32 v36 = *v23 - 2 - *v27; // R5
    uint32 v37 = *v21 - *v25 - 4; // R3
    uint32 * v38 = (uint32 *)(v1 + 48);
    *v38 = v34;
    uint32 * v39 = (uint32 *)(v1 + 52);
    *v39 = v37;
    uint32 * v40 = (uint32 *)(v1 + 56);
    *v40 = v35;
    uint32 * v41 = (uint32 *)(v1 + 60);
    *v41 = v36;
    *(uint32 *)result = v34 - *a1 - 2;
    *(uint32 *)(v1 + 36) = v37 - *v13 - 4;
    *(uint32 *)(v1 + 40) = v35 - *v14 - 2;
    *(uint32 *)(v1 + 44) = v36 - *v15 - 2;
    uint32 v42 = *v15 + *v41;
    float32_t v43 = fabsf((float32_t)v42);
    *v38 = (uint32)(v42 < 0) + *a1 + *v38;
    *v39 = *v13 + *v39;
    *v40 = *v14 + *v40;
    *v41 = (uint32)v43;
    uint32 v44 = v33 + *v19;
    float32_t v45 = fabsf((float32_t)v44);
    *a1 = v30 + *v16 + (uint32)(v44 < 0);
    *v13 = v31 + *v17;
    *v14 = v32 + *v18;
    *v15 = (uint32)v45;
    *v16 = *v16 - v30 - 2;
    *v17 = *v17 - v31 - 4;
    *v18 = *v18 - 2 - v32;
    *v19 = *v19 - 2 - v33;
}

/*
 * To be entirely sure, that the segmentation fault is not caused through bad linking or alike.
 * But with this implementation the segmentation fault is persistent. I assume it is using some
 * register or command, an unpriviliged user is not entitled to use. Hence the decompiled version
 * does work, yet the assembler version does not.
 */
/*void hadamard(uint32 *q, const uint32 *x){
		asm("push {r4-r7,lr} \n \t \
			 MOV R0, %2 \n \t \
			 MOV R1, %1 \n \t \
			 LDM R1!, {R2, R3, R4, R5} \n \t \
			 MOV R8, R2 \n \t \
			 MOV R9, R3 \n \t \
			 MOV R10, R4 \n \t \
			 MOV R11, R5 \n \t \
			 LDM R1!, {R2, R3, R4, R5} \n \t \
			 MOV R6, R8				 \n \t \
			 MOV R7, R9		 \n \t \
			 ADD R2, R6		 \n \t \
			 ADC R3, R7		 \n \t \
			 MOV R6, R10	 \n \t \
			 MOV R7, R11	 \n \t \
			 ADC R4, R6		 \n \t \
			 ADC R5, R7		 \n \t \
			 BIC R6, R6 \n \t \
			 ADC R6, R6 \n \t \
			 LSL R6, #1 \n \t \
			 LSR R7, R5, #31 \n \t \
			 LSL R5, #1 \n \t \
			 LSR R5, #1 \n \t \
			 EOR R6, R7 \n \t \
			 BIC R7, R7 \n \t \
			 ADD R2, R6 \n \t \
			 ADC R3, R7 \n \t \
			 ADC R4, R7 \n \t \
			 ADC R5, R7 \n \t \
			 STM R0!, {R2, R3, R4, R5} \n \t \
			  \n \t \
			SUB R1, #16  \n \t \
			LDM R1!, {R2, R3, R4, R5} \n \t \
			MOV R6, R8 \n \t \
			MOV R7, R9 \n \t \
			SUB R2, R6 \n \t \
			SBC R3, R7 \n \t \
			MOV R6, R10 \n \t \
			MOV R7, R11 \n \t \
			SBC R4, R6 \n \t \
			SBC R5, R7 \n \t \
			BIC R6, R6 \n \t \
			SBC R6, R6  \n \t \
			.syntax unified \n \t \
			RSBS R6, #0 \n \t \
			.syntax divided \n \t \
			LSL R6, #1 \n \t \
			BIC R7, R7 \n \t \
			SUB R2, R6 \n \t \
			SBC R3, R7 \n \t \
			SBC R4, R7 \n \t \
			SBC R5, R7 \n \t \
			SBC R7, R7  \n \t \
			.syntax unified \n \t \
			RSBS R7, #0 \n \t \
			.syntax divided \n \t \
			LSL R7, #1 \n \t \
			SUB R3, R7 \n \t \
			STM R0!, {R2, R3, R4, R5}  \n \t \
			 \n \t \
			LDM R1!, {R2, R3, R4, R5}  \n \t \
			LDM R1!, {R6, R7}  \n \t \
			ADD R2, R6 \n \t \
			ADC R3, R7 \n \t \
			LDM R1!, {R6, R7}  \n \t \
			ADC R4, R6	 \n \t \
			ADC R5, R7	 \n \t \
			BIC R6, R6	 \n \t \
			ADC R6, R6	 \n \t \
			LSL R6, #1	 \n \t \
			LSR R7, R5, #31 \n \t \
			LSL R5, #1 \n \t \
			LSR R5, #1 \n \t \
			EOR R6, R7 \n \t \
			BIC R7, R7 \n \t \
			ADD R2, R6 \n \t \
			ADC R3, R7 \n \t \
			ADC R4, R7 \n \t \
			ADC R5, R7 \n \t \
			MOV R8, R2  \n \t \
			MOV R9, R3 \n \t \
			MOV R10, R4 \n \t \
			MOV R11, R5 \n \t \
			SUB R1, #32  \n \t \
			LDM R1!, {R2, R3, R4, R5}  \n \t \
			LDM R1!, {R6, R7}  \n \t \
			SUB R2, R6 \n \t \
			SBC R3, R7 \n \t \
			LDM R1!, {R6, R7}  \n \t \
			SBC R4, R6 \n \t \
			SBC R5, R7 \n \t \
			BIC R6, R6 \n \t \
			SBC R6, R6  \n \t \
			.syntax unified \n \t \
			RSBS R6, #0 \n \t \
			.syntax divided \n \t \
			LSL R6, #1 \n \t \
			BIC R7, R7 \n \t \
			SUB R2, R6 \n \t \
			SBC R3, R7 \n \t \
			SBC R4, R7 \n \t \
			SBC R5, R7 \n \t \
			SBC R7, R7  \n \t \
			.syntax unified \n \t \
			RSBS R7, #0 \n \t \
			.syntax divided \n \t \
			LSL R7, #1 \n \t \
			SUB R3, R7 \n \t \
			ADD R0, #16 \n \t \
			STM R0!, {R2, R3, R4, R5} \n \t \
			 \n \t \
			SUB R0, #64  \n \t \
			LDM R0!, {R6, R7} \n \t \
			SUB R2, R6 \n \t \
			SBC R3, R7 \n \t \
			LDM R0!, {R6, R7} \n \t \
			SBC R4, R6 \n \t \
			SBC R5, R7 \n \t \
			BIC R6, R6 \n \t \
			SBC R6, R6  \n \t \
			.syntax unified \n \t \
			RSBS R6, #0 \n \t \
			.syntax divided \n \t \
			LSL R6, #1 \n \t \
			BIC R7, R7 \n \t \
			SUB R2, R6 \n \t \
			SBC R3, R7 \n \t \
			SBC R4, R7 \n \t \
			SBC R5, R7 \n \t \
			SBC R7, R7  \n \t \
			.syntax unified \n \t \
			RSBS R7, #0 \n \t \
			.syntax divided \n \t \
			LSL R7, #1 \n \t \
			SUB R3, R7 \n \t \
			ADD R0, #16  \n \t \
			STM R0!, {R2, R3, R4, R5} \n \t \
			 \n \t \
			LDM R0!, {R2, R3, R4, R5}  \n \t \
			SUB R0, #64  \n \t \
			LDM R0!, {R6, R7}  \n \t \
			ADD R2, R6 \n \t \
			ADC R3, R7 \n \t \
			LDM R0!, {R6, R7} \n \t \
			ADC R4, R6	 \n \t \
			ADC R5, R7  \n \t \
			BIC R6, R6	 \n \t \
			ADC R6, R6	 \n \t \
			LSL R6, #1 \n \t \
			LSR R7, R5, #31 \n \t \
			LSL R5, #1 \n \t \
			LSR R5, #1 \n \t \
			EOR R6, R7 \n \t \
			BIC R7, R7 \n \t \
			ADD R2, R6 \n \t \
			ADC R3, R7 \n \t \
			ADC R4, R7 \n \t \
			ADC R5, R7 \n \t \
			ADD R0, #32  \n \t \
			STM R0!, {R2, R3, R4, R5} \n \t \
			SUB R0, #48  \n \t \
			LDM R0!, {R2, R3, R4, R5} \n \t \
			MOV R6, R8 \n \t \
			MOV R7, R9 \n \t \
			ADD R2, R6 \n \t \
			ADC R3, R7 \n \t \
			MOV R6, R10 \n \t \
			MOV R7, R11 \n \t \
			ADC R4, R6	 \n \t \
			ADC R5, R7	 \n \t \
			BIC R6, R6	 \n \t \
			ADC R6, R6	 \n \t \
			LSL R6, #1 \n \t \
			LSR R7, R5, #31 \n \t \
			LSL R5, #1 \n \t \
			LSR R5, #1 \n \t \
			EOR R6, R7 \n \t \
			BIC R7, R7 \n \t \
			ADD R2, R6 \n \t \
			ADC R3, R7 \n \t \
			ADC R4, R7 \n \t \
			ADC R5, R7 \n \t \
			SUB R0, #32  \n \t \
			STM R0!, {R2, R3, R4, R5} \n \t \
			LDM R0!, {R2, R3, R4, R5} \n \t \
			MOV R6, R8 \n \t \
			MOV R7, R9 \n \t \
			SUB R2, R6 \n \t \
			SBC R3, R7 \n \t \
			MOV R6, R10 \n \t \
			MOV R7, R11 \n \t \
			SBC R4, R6 \n \t \
			SBC R5, R7 \n \t \
			BIC R6, R6 \n \t \
			SBC R6, R6  \n \t \
			.syntax unified \n \t \
			RSBS R6, #0 \n \t \
			.syntax divided \n \t \
			LSL R6, #1 \n \t \
			BIC R7, R7 \n \t \
			SUB R2, R6 \n \t \
			SBC R3, R7 \n \t \
			SBC R4, R7 \n \t \
			SBC R5, R7 \n \t \
			SBC R7, R7  \n \t \
			.syntax unified \n \t \
			RSBS R7, #0 \n \t \
			.syntax divided \n \t \
			LSL R7, #1 \n \t \
			SUB R3, R7 \n \t \
			SUB R0, #16 \n \t \
			STM R0!, {R2, R3, R4, R5} \n \t \
			MOV %0, R0 \n \t \
			pop {r4-r7,pc}  \n \t \
			bx lr"

			: "=r" (q) 
			: "r" (q), "r" (x));
}*/
