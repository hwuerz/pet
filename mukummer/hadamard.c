#include "gfe.h"
#include "stdlib.h"

/*
 * From: https://github.com/bvssvni/fwht/blob/master/fwht.c
 * edited by Nils Dycke
 */

/*
 * Receives a 16*uint array for r and a 16*uint array for x
 * or a 32*uint array for r and a 32*uint array for x
 * Assuming that for both cases it is supposed to be applied to the lower 16 entries.
 */
/*void hadamard(uint32 *r, const uint32 *x){
	const int n = 16; //or 32
	uint32 adata[n];
    uint32 bdata[n];
    uint32 *a = adata;
    uint32 *b = bdata;
    void *tmp;
    memcpy(a, x, sizeof(uint32)*n);
    
    // Fast Walsh Hadamard Transform.
    int i, j, s;
    for (i = n>>1; i > 0; i>>=1) {
        for (j = 0; j < n; j++) {
            s = j/i%2;
            b[j]=a[(s?-i:0)+j]+(s?-1:1)*a[(s?0:i)+j];
        }
        tmp = a; a = b; b = tmp;
    }
    
	memcpy(r, a, sizeof(uint32)*n);
}*/


//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <math.h>
#include <stdint.h>

typedef float float32_t;

void hadamard(uint32 * a1, const uint32 * a2) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = (int32_t)a2;
    int32_t v3 = *a2;
    int32_t v4 = *(int32_t *)(v2 + 4);
    int32_t v5 = *(int32_t *)(v2 + 8);
    int32_t v6 = *(int32_t *)(v2 + 12);
    int32_t * v7 = (int32_t *)(v2 + 16);
    int32_t * v8 = (int32_t *)(v2 + 20);
    int32_t * v9 = (int32_t *)(v2 + 24);
    int32_t * v10 = (int32_t *)(v2 + 28);
    int32_t v11 = *v10 + v6; // bp+38
    float32_t v12 = fabsf((float32_t)v11);
    *a1 = *v7 + v3 + (int32_t)(v11 < 0);
    int32_t * v13 = (int32_t *)(v1 + 4);
    *v13 = *v8 + v4;
    int32_t * v14 = (int32_t *)(v1 + 8);
    *v14 = *v9 + v5;
    int32_t * v15 = (int32_t *)(v1 + 12);
    *v15 = (int32_t)v12;
    int32_t * v16 = (int32_t *)(v1 + 16);
    *v16 = *v7 - v3 - 2;
    int32_t * v17 = (int32_t *)(v1 + 20);
    *v17 = *v8 - v4 - 4;
    int32_t * v18 = (int32_t *)(v1 + 24);
    *v18 = *v9 - v5 - 2;
    int32_t * v19 = (int32_t *)(v1 + 28);
    *v19 = *v10 - v6 - 2;
    int32_t result = v1 + 32;
    int32_t * v20 = (int32_t *)(v2 + 32);
    int32_t * v21 = (int32_t *)(v2 + 36);
    int32_t * v22 = (int32_t *)(v2 + 40);
    int32_t * v23 = (int32_t *)(v2 + 44);
    int32_t * v24 = (int32_t *)(v2 + 48);
    int32_t * v25 = (int32_t *)(v2 + 52);
    int32_t * v26 = (int32_t *)(v2 + 56);
    int32_t * v27 = (int32_t *)(v2 + 60);
    int32_t v28 = *v27 + *v23;
    float32_t v29 = fabsf((float32_t)v28);
    int32_t v30 = (int32_t)(v28 < 0) + *v24 + *v20; // R8
    int32_t v31 = *v25 + *v21; // R9
    int32_t v32 = *v26 + *v22; // R10
    int32_t v33 = v29; // R11
    int32_t v34 = *v20 - *v24 - 2; // bp+160
    int32_t v35 = *v22 - 2 - *v26; // R4
    int32_t v36 = *v23 - 2 - *v27; // R5
    int32_t v37 = *v21 - *v25 - 4; // R3
    int32_t * v38 = (int32_t *)(v1 + 48);
    *v38 = v34;
    int32_t * v39 = (int32_t *)(v1 + 52);
    *v39 = v37;
    int32_t * v40 = (int32_t *)(v1 + 56);
    *v40 = v35;
    int32_t * v41 = (int32_t *)(v1 + 60);
    *v41 = v36;
    *(int32_t *)result = v34 - *a1 - 2;
    *(int32_t *)(v1 + 36) = v37 - *v13 - 4;
    *(int32_t *)(v1 + 40) = v35 - *v14 - 2;
    *(int32_t *)(v1 + 44) = v36 - *v15 - 2;
    int32_t v42 = *v15 + *v41;
    float32_t v43 = fabsf((float32_t)v42);
    *v38 = (int32_t)(v42 < 0) + *a1 + *v38;
    *v39 = *v13 + *v39;
    *v40 = *v14 + *v40;
    *v41 = (int32_t)v43;
    int32_t v44 = v33 + *v19;
    float32_t v45 = fabsf((float32_t)v44);
    *a1 = v30 + *v16 + (int32_t)(v44 < 0);
    *v13 = v31 + *v17;
    *v14 = v32 + *v18;
    *v15 = (int32_t)v45;
    *v16 = *v16 - v30 - 2;
    *v17 = *v17 - v31 - 4;
    *v18 = *v18 - 2 - v32;
    *v19 = *v19 - 2 - v33;
}
